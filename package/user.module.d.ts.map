{"version":3,"sources":["../src/user.module.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAA0B,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAErF,OAAO,EAAE,gBAAgB,EAAE,MAAM,yCAAyC,CAAC;AAM3E,OAAO,EAAW,UAAU,EAAE,MAAM,SAAS,CAAC;AAK9C,OAAO,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAC;AAGzD,OAAO,EAAE,UAAU,EAAE,MAAM,8BAA8B,CAAC;AAC1D,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAAE,IAAI,EAAE,MAAM,wBAAwB,CAAC;AAE9C,OAAO,EAAE,IAAI,EAAE,MAAM,wBAAwB,CAAC;AAa9C,OAAO,EAAE,WAAW,EAAE,MAAM,yBAAyB,CAAC;AAGtD,qBAoBa,UAAW,YAAW,YAAY;IAIlB,OAAO,CAAC,QAAQ,CAAC,WAAW;IACvB,OAAO,CAAC,QAAQ,CAAC,gBAAgB;IAC/B,OAAO,CAAC,QAAQ,CAAC,YAAY;IAC3B,OAAO,CAAC,QAAQ,CAAC,cAAc;IACrC,OAAO,CAAC,QAAQ,CAAC,QAAQ;IACpB,OAAO,CAAC,QAAQ,CAAC,aAAa;IACnC,OAAO,CAAC,QAAQ,CAAC,QAAQ;IATrD,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAkB;gBAGR,WAAW,EAAE,WAAW,EACnB,gBAAgB,EAAE,gBAAgB,EAChC,YAAY,EAAE,UAAU,CAAC,QAAQ,CAAC,EAChC,cAAc,EAAE,UAAU,CAAC,UAAU,CAAC,EAC5C,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC,EACrB,aAAa,EAAE,UAAU,CAAC,SAAS,CAAC,EACzC,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC;IAKvE,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE;QAAE,IAAI,EAAE,OAAO,GAAG,OAAO,CAAA;KAAE,GAAG,aAAa;IAgB7D,YAAY;YAUJ,2BAA2B;YAsG3B,iBAAiB;YAcjB,sBAAsB;YAiBtB,gBAAgB;CAKjC","file":"user.module.d.ts","sourcesContent":["import { DynamicModule, Global, Inject, Module, OnModuleInit } from '@nestjs/common';\nimport { APP_GUARD } from '@nestjs/core';\nimport { ModulesContainer } from '@nestjs/core/injector/modules-container';\nimport { MetadataScanner } from '@nestjs/core/metadata-scanner';\nimport { InjectRepository, TypeOrmModule } from '@nestjs/typeorm';\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { __ as t, configure as i18nConfigure } from 'i18n';\nimport { join } from 'path';\nimport { In, Not, Repository } from 'typeorm';\n\nimport { AuthGurad } from './auth/auth.gurad';\nimport { AuthService } from './auth/auth.service';\nimport { PERMISSION_DEFINITION, RESOURCE_DEFINITION } from './decorators';\nimport { InfoGroup } from './entities/info-group.entity';\nimport { InfoItem } from './entities/info-item.entity';\nimport { Organization } from './entities/organization.entity';\nimport { Permission } from './entities/permission.entity';\nimport { Resource } from './entities/resource.entity';\nimport { Role } from './entities/role.entity';\nimport { UserInfo } from './entities/user-info.entity';\nimport { User } from './entities/user.entity';\nimport { InfoGroupResolver } from './resolvers/info-group.resolver';\nimport { InfoItemResolver } from './resolvers/info-item.resolver';\nimport { OrganizationResolver } from './resolvers/organization.resolver';\nimport { ResourceResolver } from './resolvers/resource.resolver';\nimport { RoleResolver } from './resolvers/role.resolver';\nimport { UserResolver } from './resolvers/user.resolver';\nimport { EntityCheckService } from './services/entity-check.service';\nimport { InfoGroupService } from './services/info-group.service';\nimport { InfoItemService } from './services/info-item.service';\nimport { OrganizationService } from './services/organization.service';\nimport { ResourceService } from './services/resource.service';\nimport { RoleService } from './services/role.service';\nimport { UserService } from './services/user.service';\nimport { CryptoUtil } from './utils/crypto.util';\n\n@Global()\n@Module({\n    imports: [\n        TypeOrmModule.forFeature([Organization, User, Role, Resource, Permission, InfoGroup, InfoItem, UserInfo])\n    ],\n    controllers: [],\n    providers: [\n        { provide: APP_GUARD, useClass: AuthGurad },\n        AuthService,\n        EntityCheckService,\n        OrganizationResolver, OrganizationService,\n        UserResolver, UserService,\n        RoleResolver, RoleService,\n        ResourceResolver, ResourceService,\n        InfoGroupResolver, InfoGroupService,\n        InfoItemResolver, InfoItemService,\n        CryptoUtil\n    ],\n    exports: [AuthService, OrganizationService, UserService, RoleService, InfoGroupService, InfoItemService]\n})\nexport class UserModule implements OnModuleInit {\n    private readonly metadataScanner: MetadataScanner;\n\n    constructor(\n        @Inject(UserService) private readonly userService: UserService,\n        @Inject(ModulesContainer) private readonly modulesContainer: ModulesContainer,\n        @InjectRepository(Resource) private readonly resourceRepo: Repository<Resource>,\n        @InjectRepository(Permission) private readonly permissionRepo: Repository<Permission>,\n        @InjectRepository(Role) private readonly roleRepo: Repository<Role>,\n        @InjectRepository(InfoGroup) private readonly infoGroupRepo: Repository<InfoGroup>,\n        @InjectRepository(User) private readonly userRepo: Repository<User>\n    ) {\n        this.metadataScanner = new MetadataScanner();\n    }\n\n    static forRoot(options: { i18n: 'en-US' | 'zh-CN' }): DynamicModule {\n        if (!existsSync('src/i18n')) {\n            mkdirSync(join('src/i18n'));\n            writeFileSync(join('src/i18n', 'zh-CN.json'), readFileSync(__dirname + '/i18n/zh-CN.json'));\n            writeFileSync(join('src/i18n', 'en-US.json'), readFileSync(__dirname + '/i18n/en-US.json'));\n        }\n        i18nConfigure({\n            locales: ['en-US', 'zh-CN'],\n            defaultLocale: options.i18n,\n            directory: 'src/i18n'\n        });\n        return {\n            module: UserModule\n        };\n    }\n\n    async onModuleInit() {\n        await this.loadResourcesAndPermissions();\n        await this.createDefaultRole();\n        await this.createDefaultInfoGroup();\n        await this.createSuperAdmin();\n    }\n\n    /**\n     * Load resources, permission annotations, and save them to the database\n     */\n    private async loadResourcesAndPermissions() {\n        const metadataMap: Map<string, { resource: Resource, permissions: Permission[] }> = new Map();\n        // Iterate Modules from module container\n        this.modulesContainer.forEach(module => {\n            for (const [key, value] of [...module.components, ...module.routes]) {\n                const isResolverOrController =\n                    Reflect.getMetadataKeys(value.instance.constructor)\n                        .filter(key => ['graphql:resolver_type', 'path']\n                            .includes(key)).length > 0;\n\n                if (isResolverOrController) {\n                    // Get the metadata in the @Resource() annotation on the Resolver or Controller class\n                    const resource: Resource = Reflect.getMetadata(RESOURCE_DEFINITION, value.instance.constructor);\n                    // Get the prototype object of the Resolver or Controller class\n                    const prototype = Object.getPrototypeOf(value.instance);\n                    if (prototype) {\n                        // Get the method name in the Resolver or Controller class,\n                        // the name in the callback function is the method name in the current class\n                        const permissions: Permission[] = this.metadataScanner.scanFromPrototype(value.instance, prototype, name => {\n                            // Get the metadata in the @Permission() annotation on the method in the Resolver or Controller class\n                            return Reflect.getMetadata(PERMISSION_DEFINITION, value.instance, name);\n                        });\n                        // If the metadata exists, it will be added to the resource collection,\n                        // and it will be automatically deduplicated according to resource.indetify\n                        if (resource) {\n                            // Translate the resources name\n                            resource.name = t(resource.name);\n                            // Translate the permissions name\n                            permissions.forEach(permission => {\n                                permission.name = t(permission.name);\n                            });\n                            metadataMap.set(resource.identify, { resource, permissions });\n                        }\n                    }\n                }\n            }\n        });\n\n        /**\n         * LOOK ME:\n         *\n         * The following are the create and delete logic for resources and permissions.\n         *\n         * When the permission uniquely identifies the change,\n         * the relationship between the changed permission and the corresponding role will also be deleted.\n         *\n         */\n\n        // All resource annotations and all permission annotations that were scanned\n        const scannedResourcesAndPermissions = [...metadataMap.values()].map(metadataValue => {\n            // Bind permissions to the corresponding resource\n            metadataValue.permissions.forEach(v => v.resource = metadataValue.resource);\n            return { permissions: metadataValue.permissions, resource: metadataValue.resource };\n        });\n\n        // All resource annotations that were scanned\n        const scannedResources = scannedResourcesAndPermissions.map(v => v.resource);\n\n        // Remove the resources and their permissions which were removed from the annotation\n        const resourceIdentifies = [...metadataMap.keys()].length === 0 ? ['__delete_all_resource__'] : [...metadataMap.keys()];\n        const notExistResources = await this.resourceRepo.find({ where: { identify: Not(In(resourceIdentifies)) } });\n        if (notExistResources.length > 0) await this.resourceRepo.delete(notExistResources.map(v => v.id));\n        // Filter out the new resources\n        const existResources = await this.resourceRepo.find({ order: { id: 'ASC' } });\n        const newResourcess = scannedResources.filter(sr => !existResources.map(v => v.identify).includes(sr.identify));\n        // Save the new resources\n        if (newResourcess.length > 0) await this.resourceRepo.save(this.resourceRepo.create(newResourcess));\n        // Update existing resources name\n        existResources.forEach(er => {\n            er.name = scannedResources.find(sr => sr.identify === er.identify).name;\n        });\n        await this.resourceRepo.save(existResources);\n\n        // All permission annotations that were scanned\n        const scannedPermissions = <Permission[]>[].concat(...scannedResourcesAndPermissions.map(v => v.permissions));\n        // Query the resources of all the permission annotations scanned\n        const resource = await this.resourceRepo.find({ where: { identify: In(scannedPermissions.map(v => v.resource.identify)) } });\n        // Bind resources to permissions\n        scannedPermissions.forEach(permission => {\n            permission.resource = resource.find(v => v.identify === permission.resource.identify);\n        });\n        // Remove the permissions that were removed from annotations\n        // tslint:disable-next-line:max-line-length\n        const permissionIdentifies = scannedPermissions.map(v => v.identify).length === 0 ? ['__delete_all_permission__'] : scannedPermissions.map(v => v.identify);\n        const notExistPermissions = await this.permissionRepo.find({ where: { identify: Not(In(permissionIdentifies)) } });\n        if (notExistPermissions.length > 0) await this.permissionRepo.delete(notExistPermissions.map(v => v.id));\n        // Filter out the new permissions\n        const existPermissions = await this.permissionRepo.find({ order: { id: 'ASC' } });\n        const newPermissions = scannedPermissions.filter(sp => !existPermissions.map(v => v.identify).includes(sp.identify));\n        // Save the new permissions\n        if (newPermissions.length > 0) await this.permissionRepo.save(this.permissionRepo.create(newPermissions));\n        // Update existing permissions name\n        existPermissions.forEach(ep => {\n            ep.name = scannedPermissions.find(sp => sp.identify === ep.identify).name;\n            ep.action = scannedPermissions.find(sp => sp.identify === ep.identify).action;\n        });\n        await this.permissionRepo.save(existPermissions);\n    }\n\n    /**\n     * Create a default ordinary user role\n     */\n    private async createDefaultRole() {\n        const defaultRole = await this.roleRepo.findOne(1);\n\n        if (defaultRole) return;\n\n        await this.roleRepo.save(this.roleRepo.create({\n            id: 1,\n            name: t('ordinary user')\n        }));\n    }\n\n    /**\n     * Create a default information group\n     */\n    private async createDefaultInfoGroup() {\n        const defaultInfoGroup = await this.infoGroupRepo.findOne(1);\n\n        if (defaultInfoGroup) return;\n\n        await this.infoGroupRepo.save(this.infoGroupRepo.create({\n            id: 1,\n            name: t('ordinary user information group'),\n            role: {\n                id: 1\n            }\n        }));\n    }\n\n    /**\n     * Create a system super administrator\n     */\n    private async createSuperAdmin() {\n        const sadmin = await this.userRepo.findOne({ where: { username: 'sadmin' } });\n        if (sadmin) return;\n        await this.userService.createUser({ username: 'sadmin', password: 'sadmin' });\n    }\n}"]}