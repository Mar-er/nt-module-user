{"version":3,"sources":["../src/user.module.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAA0B,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAErF,OAAO,EAAE,gBAAgB,EAAE,MAAM,yCAAyC,CAAC;AAO3E,OAAO,EAAW,UAAU,EAAE,MAAM,SAAS,CAAC;AAM9C,OAAO,EAAE,SAAS,EAAE,MAAM,8BAA8B,CAAC;AAGzD,OAAO,EAAE,UAAU,EAAE,MAAM,8BAA8B,CAAC;AAC1D,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAAE,IAAI,EAAE,MAAM,wBAAwB,CAAC;AAC9C,OAAO,EAAE,YAAY,EAAE,MAAM,iCAAiC,CAAC;AAE/D,OAAO,EAAE,IAAI,EAAE,MAAM,wBAAwB,CAAC;AAe9C,OAAO,EAAE,WAAW,EAAE,MAAM,yBAAyB,CAAC;AAGtD,qBAsBa,UAAW,YAAW,YAAY;IAIlB,OAAO,CAAC,QAAQ,CAAC,WAAW;IACvB,OAAO,CAAC,QAAQ,CAAC,gBAAgB;IAC3B,OAAO,CAAC,QAAQ,CAAC,gBAAgB;IACrC,OAAO,CAAC,QAAQ,CAAC,YAAY;IAC3B,OAAO,CAAC,QAAQ,CAAC,cAAc;IACrC,OAAO,CAAC,QAAQ,CAAC,QAAQ;IACpB,OAAO,CAAC,QAAQ,CAAC,aAAa;IACnC,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAVrD,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAkB;gBAGR,WAAW,EAAE,WAAW,EACnB,gBAAgB,EAAE,gBAAgB,EAC5B,gBAAgB,EAAE,UAAU,CAAC,YAAY,CAAC,EAC9C,YAAY,EAAE,UAAU,CAAC,QAAQ,CAAC,EAChC,cAAc,EAAE,UAAU,CAAC,UAAU,CAAC,EAC5C,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC,EACrB,aAAa,EAAE,UAAU,CAAC,SAAS,CAAC,EACzC,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC;IAKvE,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE;QAAE,IAAI,EAAE,OAAO,GAAG,OAAO,CAAC;QAAC,kBAAkB,CAAC,EAAE,MAAM,EAAE,CAAA;KAAE,GAAG,aAAa;IAsB5F,YAAY;YAUJ,2BAA2B;YAiH3B,iBAAiB;YAcjB,sBAAsB;YAiBtB,gBAAgB;CAKjC","file":"user.module.d.ts","sourcesContent":["import { DynamicModule, Global, Inject, Module, OnModuleInit } from '@nestjs/common';\nimport { APP_GUARD } from '@nestjs/core';\nimport { ModulesContainer } from '@nestjs/core/injector/modules-container';\nimport { MetadataScanner } from '@nestjs/core/metadata-scanner';\nimport { InjectRepository, TypeOrmModule } from '@nestjs/typeorm';\nimport { SmsModule } from '@notadd/addon-sms';\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { __ as t, configure as i18nConfigure } from 'i18n';\nimport { join } from 'path';\nimport { In, Not, Repository } from 'typeorm';\n\nimport { AuthGuard } from './auth/auth.guard';\nimport { AuthService } from './auth/auth.service';\nimport { AUTH_TOKEN_WHITE_LIST } from './constants/auth.constant';\nimport { PERMISSION_DEFINITION, RESOURCE_DEFINITION } from './decorators';\nimport { InfoGroup } from './entities/info-group.entity';\nimport { InfoItem } from './entities/info-item.entity';\nimport { Organization } from './entities/organization.entity';\nimport { Permission } from './entities/permission.entity';\nimport { Resource } from './entities/resource.entity';\nimport { Role } from './entities/role.entity';\nimport { SystemModule } from './entities/system-module.entity';\nimport { UserInfo } from './entities/user-info.entity';\nimport { User } from './entities/user.entity';\nimport { InfoGroupResolver } from './resolvers/info-group.resolver';\nimport { InfoItemResolver } from './resolvers/info-item.resolver';\nimport { OrganizationResolver } from './resolvers/organization.resolver';\nimport { ResourceResolver } from './resolvers/resource.resolver';\nimport { RoleResolver } from './resolvers/role.resolver';\nimport { SystemModuleResolver } from './resolvers/system-module.resolver';\nimport { UserResolver } from './resolvers/user.resolver';\nimport { EntityCheckService } from './services/entity-check.service';\nimport { InfoGroupService } from './services/info-group.service';\nimport { InfoItemService } from './services/info-item.service';\nimport { OrganizationService } from './services/organization.service';\nimport { ResourceService } from './services/resource.service';\nimport { RoleService } from './services/role.service';\nimport { SystemModuleService } from './services/system-module.service';\nimport { UserService } from './services/user.service';\nimport { CryptoUtil } from './utils/crypto.util';\n\n@Global()\n@Module({\n    imports: [\n        TypeOrmModule.forFeature([Organization, User, Role, SystemModule, Resource, Permission, InfoGroup, InfoItem, UserInfo]),\n        SmsModule\n    ],\n    controllers: [],\n    providers: [\n        { provide: APP_GUARD, useClass: AuthGuard },\n        AuthService,\n        EntityCheckService,\n        OrganizationResolver, OrganizationService,\n        UserResolver, UserService,\n        RoleResolver, RoleService,\n        SystemModuleResolver, SystemModuleService,\n        ResourceResolver, ResourceService,\n        InfoGroupResolver, InfoGroupService,\n        InfoItemResolver, InfoItemService,\n        CryptoUtil\n    ],\n    exports: [AuthService, OrganizationService, UserService, RoleService, InfoGroupService, InfoItemService]\n})\nexport class UserModule implements OnModuleInit {\n    private readonly metadataScanner: MetadataScanner;\n\n    constructor(\n        @Inject(UserService) private readonly userService: UserService,\n        @Inject(ModulesContainer) private readonly modulesContainer: ModulesContainer,\n        @InjectRepository(SystemModule) private readonly systemModuleRepo: Repository<SystemModule>,\n        @InjectRepository(Resource) private readonly resourceRepo: Repository<Resource>,\n        @InjectRepository(Permission) private readonly permissionRepo: Repository<Permission>,\n        @InjectRepository(Role) private readonly roleRepo: Repository<Role>,\n        @InjectRepository(InfoGroup) private readonly infoGroupRepo: Repository<InfoGroup>,\n        @InjectRepository(User) private readonly userRepo: Repository<User>\n    ) {\n        this.metadataScanner = new MetadataScanner();\n    }\n\n    static forRoot(options: { i18n: 'en-US' | 'zh-CN', authTokenWhiteList?: string[] }): DynamicModule {\n        if (!existsSync('src/i18n')) {\n            mkdirSync(join('src/i18n'));\n            writeFileSync(join('src/i18n', 'zh-CN.json'), readFileSync(__dirname + '/i18n/zh-CN.json'));\n            writeFileSync(join('src/i18n', 'en-US.json'), readFileSync(__dirname + '/i18n/en-US.json'));\n        }\n        i18nConfigure({\n            locales: ['en-US', 'zh-CN'],\n            defaultLocale: options.i18n,\n            directory: 'src/i18n'\n        });\n        if (options.authTokenWhiteList) {\n            options.authTokenWhiteList.push(...['IntrospectionQuery', 'login', 'adminLogin', 'register']);\n        } else {\n            options.authTokenWhiteList = ['IntrospectionQuery', 'login', 'adminLogin', 'register'];\n        }\n        return {\n            providers: [{ provide: AUTH_TOKEN_WHITE_LIST, useValue: options.authTokenWhiteList }],\n            module: UserModule\n        };\n    }\n\n    async onModuleInit() {\n        await this.loadResourcesAndPermissions();\n        await this.createDefaultRole();\n        await this.createDefaultInfoGroup();\n        await this.createSuperAdmin();\n    }\n\n    /**\n     * Load resources, permission annotations, and save them to the database\n     */\n    private async loadResourcesAndPermissions() {\n        const metadataMap: Map<string, { name: string, resource: Resource[] }> = new Map();\n        this.modulesContainer.forEach((moduleValue, moduleKey) => {\n            for (const [componentKey, componentKeyValue] of [...moduleValue.components, ...moduleValue.routes]) {\n                const isResolverOrController =\n                    Reflect.getMetadataKeys(componentKeyValue.instance.constructor)\n                        .filter(key => ['graphql:resolver_type', 'path']\n                            .includes(key)).length > 0;\n\n                if (isResolverOrController) {\n                    const resource: Resource = Reflect.getMetadata(RESOURCE_DEFINITION, componentKeyValue.instance.constructor);\n                    const prototype = Object.getPrototypeOf(componentKeyValue.instance);\n\n                    if (resource && prototype) {\n                        const permissions: Permission[] = this.metadataScanner.scanFromPrototype(componentKeyValue.instance, prototype, name => {\n                            return Reflect.getMetadata(PERMISSION_DEFINITION, componentKeyValue.instance, name);\n                        });\n                        resource.permissions = permissions;\n\n                        if (metadataMap.has(moduleKey)) {\n                            metadataMap.get(moduleKey).name = t(moduleValue.metatype.name);\n                            metadataMap.get(moduleKey).resource.push(resource);\n                        } else {\n                            metadataMap.set(moduleKey, { name: t(moduleValue.metatype.name), resource: [resource] });\n                        }\n                    }\n                }\n            }\n        });\n\n        metadataMap.forEach(value => {\n            value.resource.forEach(resource => {\n                resource.name = t(resource.name);\n                resource.permissions.forEach(p => p.name = t(p.name));\n            });\n        });\n\n        // Sacnned modules\n        const scannedModules = [...metadataMap.values()].map(v => ({ name: v.name }));\n\n        // Delete removed module\n        const notExistingModule = await this.systemModuleRepo.find({\n            where: { name: Not(In(scannedModules.length ? scannedModules.map(v => v.name) : ['__delete_all_system_module__'])) }\n        });\n        if (notExistingModule.length) await this.systemModuleRepo.delete(notExistingModule.map(v => v.id));\n        // Create new module\n        const existingModules = await this.systemModuleRepo.find({ order: { id: 'ASC' } });\n        const newModules = scannedModules.filter(sm => !existingModules.map(v => v.name).includes(sm.name));\n        if (newModules.length) await this.systemModuleRepo.save(this.systemModuleRepo.create(newModules));\n        // Update existing module\n        if (existingModules.length) {\n            existingModules.forEach(em => {\n                em.name = scannedModules.find(sm => sm.name === em.name).name;\n            });\n            await this.systemModuleRepo.save(existingModules);\n        }\n\n        // Sacnned resources\n        for (const [key, value] of metadataMap) {\n            const resourceModule = await this.systemModuleRepo.findOne({ where: { name: value.name } });\n            value.resource.forEach(async resouece => {\n                resouece.systemModule = resourceModule;\n            });\n        }\n        const scannedResources: Resource[] = <Resource[]>[].concat(...[...metadataMap.values()].map(v => v.resource));\n\n        // Delete removed resource\n        const resourceIdentifies = scannedResources.length ? scannedResources.map(v => v.identify) : ['__delete_all_resource__'];\n        const notExistResources = await this.resourceRepo.find({ where: { identify: Not(In(resourceIdentifies)) } });\n        if (notExistResources.length > 0) await this.resourceRepo.delete(notExistResources.map(v => v.id));\n        // Create new resource\n        const existResources = await this.resourceRepo.find({ order: { id: 'ASC' } });\n        const newResourcess = scannedResources.filter(sr => !existResources.map(v => v.identify).includes(sr.identify));\n        if (newResourcess.length > 0) await this.resourceRepo.save(this.resourceRepo.create(newResourcess));\n        // Update resource\n        if (existResources.length) {\n            existResources.forEach(er => {\n                er.name = scannedResources.find(sr => sr.identify === er.identify).name;\n            });\n            await this.resourceRepo.save(existResources);\n        }\n\n        // Sacnned permissions\n        const scannedPermissions = <Permission[]>[].concat(...scannedResources.map(metadataValue => {\n            metadataValue.permissions.forEach(v => v.resource = metadataValue);\n            return metadataValue.permissions;\n        }));\n        // Delete removed permission\n        const resource = await this.resourceRepo.find({ where: { identify: In(scannedPermissions.map(v => v.resource.identify)) } });\n        scannedPermissions.forEach(permission => {\n            permission.resource = resource.find(v => v.identify === permission.resource.identify);\n        });\n        // Create removed permission\n        const permissionIdentifies = scannedPermissions.length ? scannedPermissions.map(v => v.identify) : ['__delete_all_permission__'];\n        const notExistPermissions = await this.permissionRepo.find({ where: { identify: Not(In(permissionIdentifies)) } });\n        if (notExistPermissions.length > 0) await this.permissionRepo.delete(notExistPermissions.map(v => v.id));\n\n        const existPermissions = await this.permissionRepo.find({ order: { id: 'ASC' } });\n        const newPermissions = scannedPermissions.filter(sp => !existPermissions.map(v => v.identify).includes(sp.identify));\n        if (newPermissions.length > 0) await this.permissionRepo.save(this.permissionRepo.create(newPermissions));\n        // Update permission\n        if (existPermissions.length) {\n            existPermissions.forEach(ep => {\n                ep.name = scannedPermissions.find(sp => sp.identify === ep.identify).name;\n                ep.action = scannedPermissions.find(sp => sp.identify === ep.identify).action;\n            });\n            await this.permissionRepo.save(existPermissions);\n        }\n    }\n\n    /**\n     * Create a default ordinary user role\n     */\n    private async createDefaultRole() {\n        const defaultRole = await this.roleRepo.findOne(1);\n\n        if (defaultRole) return;\n\n        await this.roleRepo.save(this.roleRepo.create({\n            id: 1,\n            name: t('ordinary user')\n        }));\n    }\n\n    /**\n     * Create a default information group\n     */\n    private async createDefaultInfoGroup() {\n        const defaultInfoGroup = await this.infoGroupRepo.findOne(1);\n\n        if (defaultInfoGroup) return;\n\n        await this.infoGroupRepo.save(this.infoGroupRepo.create({\n            id: 1,\n            name: t('ordinary user information group'),\n            role: {\n                id: 1\n            }\n        }));\n    }\n\n    /**\n     * Create a system super administrator\n     */\n    private async createSuperAdmin() {\n        const sadmin = await this.userRepo.findOne({ where: { username: 'sadmin' } });\n        if (sadmin) return;\n        await this.userService.createUser({ username: 'sadmin', password: 'sadmin' });\n    }\n}"]}