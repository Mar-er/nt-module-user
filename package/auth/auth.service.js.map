{"version":3,"sources":["../src/auth/auth.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,2CAAgE;AAChE,2DAAyD;AACzD,+BAA+B;AAC/B,oCAAoC;AAEpC,8DAAmE;AAGnE,2DAAuD;AAGvD,IAAa,WAAW,GAAxB,MAAa,WAAW;IACpB,YAC4D,WAAwB,EAChC,kBAA4B;QADpB,gBAAW,GAAX,WAAW,CAAa;QAChC,uBAAkB,GAAlB,kBAAkB,CAAU;IAC5E,CAAC;IAEL,KAAK,CAAC,WAAW,CAAC,OAAmB;QACjC,MAAM,WAAW,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QACxE,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,GAAQ;QACvB,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;YACtE,OAAO;SACV;QAED,IAAI,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,aAAuB,CAAC;QAChD,IAAI,CAAC,KAAK,EAAE;YACR,MAAM,IAAI,wCAAmB,CAAC,SAAC,CAAC,4FAA4F,CAAC,CAAC,CAAC;SAClI;QAED,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;YACpD,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SAC1B;aAAM;YACH,MAAM,IAAI,wCAAmB,CAAC,SAAC,CAAC,4EAA4E,CAAC,CAAC,CAAC;SAClH;QAED,IAAI;YACA,MAAM,YAAY,GAA0B,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;YAC3E,OAAO,IAAI,CAAC,WAAW,CAAC,8BAA8B,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SAClF;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,KAAK,YAAY,GAAG,CAAC,iBAAiB,EAAE;gBACxC,MAAM,IAAI,wCAAmB,CAAC,SAAC,CAAC,qCAAqC,CAAC,CAAC,CAAC;aAC3E;YACD,IAAI,KAAK,YAAY,GAAG,CAAC,iBAAiB,EAAE;gBACxC,MAAM,IAAI,wCAAmB,CAAC,SAAC,CAAC,oCAAoC,CAAC,CAAC,CAAC;aAC1E;SACJ;IACL,CAAC;CACJ,CAAA;AAvCY,WAAW;IADvB,mBAAU,EAAE;IAGJ,WAAA,eAAM,CAAC,mBAAU,CAAC,GAAG,EAAE,CAAC,0BAAW,CAAC,CAAC,CAAA;IACrC,WAAA,eAAM,CAAC,qCAAqB,CAAC,CAAA;qCADuC,0BAAW;GAF3E,WAAW,CAuCvB;AAvCY,kCAAW","file":"auth.service.js","sourcesContent":["import { forwardRef, Inject, Injectable } from '@nestjs/common';\nimport { AuthenticationError } from 'apollo-server-core';\nimport { __ as t } from 'i18n';\nimport * as jwt from 'jsonwebtoken';\n\nimport { AUTH_TOKEN_WHITE_LIST } from '../constants/auth.constant';\nimport { User } from '../entities/user.entity';\nimport { JwtPayload, JwtReply } from '../interfaces/jwt.interface';\nimport { UserService } from '../services/user.service';\n\n@Injectable()\nexport class AuthService {\n    constructor(\n        @Inject(forwardRef(() => UserService)) private readonly userService: UserService,\n        @Inject(AUTH_TOKEN_WHITE_LIST) private readonly authTokenWhiteList: [string]\n    ) { }\n\n    async createToken(payload: JwtPayload): Promise<JwtReply> {\n        const accessToken = jwt.sign(payload, 'secretKey', { expiresIn: '1d' });\n        return { accessToken, expiresIn: 60 * 60 * 24 };\n    }\n\n    async validateUser(req: any): Promise<User> {\n        if (req.body && this.authTokenWhiteList.includes(req.body.operationName)) {\n            return;\n        }\n\n        let token = req.headers.authorization as string;\n        if (!token) {\n            throw new AuthenticationError(t('Request header lacks authorization parametersï¼Œit should be: Authorization or authorization'));\n        }\n\n        if (['Bearer ', 'bearer '].includes(token.slice(0, 7))) {\n            token = token.slice(7);\n        } else {\n            throw new AuthenticationError(t('The authorization code prefix is incorrect. it should be: Bearer or bearer'));\n        }\n\n        try {\n            const decodedToken = <{ loginName: string }>jwt.verify(token, 'secretKey');\n            return this.userService.findOneWithRolesAndPermissions(decodedToken.loginName);\n        } catch (error) {\n            if (error instanceof jwt.JsonWebTokenError) {\n                throw new AuthenticationError(t('The authorization code is incorrect'));\n            }\n            if (error instanceof jwt.TokenExpiredError) {\n                throw new AuthenticationError(t('The authorization code has expired'));\n            }\n        }\n    }\n}"]}