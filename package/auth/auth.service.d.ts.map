{"version":3,"sources":["../src/auth/auth.service.ts"],"names":[],"mappings":"AAKA,OAAO,EAAE,IAAI,EAAE,MAAM,yBAAyB,CAAC;AAC/C,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,MAAM,6BAA6B,CAAC;AACnE,OAAO,EAAE,WAAW,EAAE,MAAM,0BAA0B,CAAC;AAEvD,qBACa,WAAW;IAEuB,OAAO,CAAC,QAAQ,CAAC,WAAW;gBAAX,WAAW,EAAE,WAAW;IAG9E,WAAW,CAAC,OAAO,EAAE,UAAU,GAAG,OAAO,CAAC,QAAQ,CAAC;IAKnD,YAAY,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC;CA+B9C","file":"auth.service.d.ts","sourcesContent":["import { forwardRef, Inject, Injectable } from '@nestjs/common';\nimport { AuthenticationError } from 'apollo-server-core';\nimport { __ as t } from 'i18n';\nimport * as jwt from 'jsonwebtoken';\n\nimport { User } from '../entities/user.entity';\nimport { JwtPayload, JwtReply } from '../interfaces/jwt.interface';\nimport { UserService } from '../services/user.service';\n\n@Injectable()\nexport class AuthService {\n    constructor(\n        @Inject(forwardRef(() => UserService)) private readonly userService: UserService\n    ) { }\n\n    async createToken(payload: JwtPayload): Promise<JwtReply> {\n        const accessToken = jwt.sign(payload, 'secretKey', { expiresIn: '1d' });\n        return { accessToken, expiresIn: 60 * 60 * 24 };\n    }\n\n    async validateUser(req: any): Promise<User> {\n        /**\n         * whitelist\n         */\n        if (req.body && ['IntrospectionQuery', 'login', 'register'].includes(req.body.operationName)) {\n            return;\n        }\n\n        let token = req.headers.authorization as string;\n        if (!token) {\n            throw new AuthenticationError(t('Request header lacks authorization parametersï¼Œit should be: Authorization or authorization'));\n        }\n\n        if (['Bearer ', 'bearer '].includes(token.slice(0, 7))) {\n            token = token.slice(7);\n        } else {\n            throw new AuthenticationError(t('The authorization code prefix is incorrect. it should be: Bearer or bearer'));\n        }\n\n        try {\n            const decodedToken = <{ username: string }>jwt.verify(token, 'secretKey');\n            return this.userService.findOneWithRolesAndPermissions(decodedToken.username);\n        } catch (error) {\n            if (error instanceof jwt.JsonWebTokenError) {\n                throw new AuthenticationError(t('The authorization code is incorrect'));\n            }\n            if (error instanceof jwt.TokenExpiredError) {\n                throw new AuthenticationError(t('The authorization code has expired'));\n            }\n        }\n    }\n}"]}