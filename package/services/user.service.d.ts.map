{"version":3,"sources":["../src/services/user.service.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,OAAO,EAAE,UAAU,EAAE,MAAM,SAAS,CAAC;AAErC,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,EAAE,QAAQ,EAAE,MAAM,8BAA8B,CAAC;AACxD,OAAO,EAAE,QAAQ,EAAE,MAAM,8BAA8B,CAAC;AACxD,OAAO,EAAE,IAAI,EAAE,MAAM,yBAAyB,CAAC;AAC/C,OAAO,EAAE,eAAe,EAAE,eAAe,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAC9F,OAAO,EAAE,UAAU,EAAE,MAAM,sBAAsB,CAAC;AAClD,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAE7C,qBACa,WAAW;IAEQ,OAAO,CAAC,QAAQ,CAAC,QAAQ;IACrB,OAAO,CAAC,QAAQ,CAAC,YAAY;IAC7B,OAAO,CAAC,QAAQ,CAAC,YAAY;IACrC,OAAO,CAAC,QAAQ,CAAC,UAAU;IACR,OAAO,CAAC,QAAQ,CAAC,WAAW;IAC9C,OAAO,CAAC,QAAQ,CAAC,WAAW;IACpB,OAAO,CAAC,QAAQ,CAAC,oBAAoB;gBANzB,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC,EACtB,YAAY,EAAE,UAAU,CAAC,QAAQ,CAAC,EAClC,YAAY,EAAE,UAAU,CAAC,QAAQ,CAAC,EAC1C,UAAU,EAAE,UAAU,EACH,WAAW,EAAE,WAAW,EAC1C,WAAW,EAAE,WAAW,EAChB,oBAAoB,EAAE,YAAY;IAQ9E,UAAU,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;IAmC3D,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IAU1C,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IAS7C,gBAAgB,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,GAAG,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;IAgBtE,UAAU,CAAC,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAYrC,0BAA0B,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,UAAU,GAAG,QAAQ;IAiBpE,cAAc,CAAC,EAAE,EAAE,MAAM,EAAE,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;IAgD3E,YAAY,CAAC,MAAM,EAAE,MAAM;IAiB3B,oBAAoB,CAAC,cAAc,EAAE,MAAM,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;IAiBrE,8BAA8B,CAAC,SAAS,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAoBhE,gBAAgB,CAAC,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,OAAO,CAAC,YAAY,GAAG,YAAY,EAAE,CAAC;IAgC/E,6BAA6B,CAAC,OAAO,EAAE,MAAM,EAAE;IAU/C,KAAK,CAAC,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM;;;;IAsCzC,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM;;;;IA0BlD,QAAQ,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;IAK/D,OAAO,CAAC,eAAe;YAUT,WAAW;YAiBX,uBAAuB;IAwBrC,OAAO,CAAC,gBAAgB;CA6B3B","file":"user.service.d.ts","sourcesContent":["import { forwardRef, HttpException, Inject, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { SmsComponent } from '@notadd/addon-sms';\nimport { __ as t } from 'i18n';\nimport { Repository } from 'typeorm';\n\nimport { AuthService } from '../auth/auth.service';\nimport { InfoItem } from '../entities/info-item.entity';\nimport { UserInfo } from '../entities/user-info.entity';\nimport { User } from '../entities/user.entity';\nimport { CreateUserInput, UpdateUserInput, UserInfoData } from '../interfaces/user.interface';\nimport { CryptoUtil } from '../utils/crypto.util';\nimport { RoleService } from './role.service';\n\n@Injectable()\nexport class UserService {\n    constructor(\n        @InjectRepository(User) private readonly userRepo: Repository<User>,\n        @InjectRepository(UserInfo) private readonly userInfoRepo: Repository<UserInfo>,\n        @InjectRepository(InfoItem) private readonly infoItemRepo: Repository<InfoItem>,\n        @Inject(CryptoUtil) private readonly cryptoUtil: CryptoUtil,\n        @Inject(forwardRef(() => AuthService)) private readonly authService: AuthService,\n        @Inject(RoleService) private readonly roleService: RoleService,\n        @Inject('SmsComponentToken') private readonly smsComponentProvider: SmsComponent\n    ) { }\n\n    /**\n     * Cteate a user\n     *\n     * @param user The user object\n     */\n    async createUser(createUserInput: CreateUserInput): Promise<void> {\n        if (!(createUserInput.username || createUserInput.mobile || createUserInput.email)) {\n            throw new HttpException(t('Please make sure the username, mobile phone number, and email exist at least one'), 406);\n        }\n        if (createUserInput.username && await this.userRepo.findOne({ where: { username: createUserInput.username } })) {\n            throw new HttpException(t('Username already exists'), 409);\n        }\n        if (createUserInput.mobile && await this.userRepo.findOne({ where: { mobile: createUserInput.mobile } })) {\n            throw new HttpException(t('Mobile already exists'), 409);\n        }\n        if (createUserInput.email && await this.userRepo.findOne({ where: { email: createUserInput.email } })) {\n            throw new HttpException(t('Email already exists'), 409);\n        }\n\n        createUserInput.password = await this.cryptoUtil.encryptPassword(createUserInput.password);\n        if (createUserInput.email) createUserInput.email = createUserInput.email.toLocaleLowerCase();\n        const user = await this.userRepo.save(this.userRepo.create(createUserInput));\n\n        if (createUserInput.roleIds && createUserInput.roleIds.length) {\n            await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(user).add(createUserInput.roleIds);\n        }\n        if (createUserInput.organizationIds && createUserInput.organizationIds.length) {\n            await this.userRepo.createQueryBuilder('user').relation(User, 'organizations').of(user).add(createUserInput.organizationIds);\n        }\n        if (createUserInput.infoKVs && createUserInput.infoKVs.length) {\n            await this.createOrUpdateUserInfos(user, createUserInput.infoKVs, 'create');\n        }\n    }\n\n    /**\n     * Add a role to the user\n     *\n     * @param userId The specified user id\n     * @param roleId The specified role id\n     */\n    async addUserRole(userId: number, roleId: number) {\n        await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(userId).add(roleId);\n    }\n\n    /**\n     * Delete a role from the user\n     *\n     * @param userId The specified user id\n     * @param roleId The specified role id\n     */\n    async deleteUserRole(userId: number, roleId: number) {\n        await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(userId).remove(roleId);\n    }\n\n    /**\n     * Delete user to recycle bin or ban user\n     *\n     * @param id The specified user id\n     */\n    async recycleOrBanUser(id: number, action: 'recycle' | 'ban'): Promise<void> {\n        const user = await this.findOneById(id);\n        if (action === 'recycle') {\n            user.recycle = true;\n        }\n        if (action === 'ban') {\n            user.banned = true;\n        }\n        await this.userRepo.save(user);\n    }\n\n    /**\n     * Delete users in the recycle bin\n     *\n     * @param id The specified user id\n     */\n    async deleteUser(id: number): Promise<void> {\n        const user = await this.userRepo.findOne(id, { relations: ['roles', 'organizations'] });\n        await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(user).remove(user.roles);\n        await this.userRepo.createQueryBuilder('user').relation(User, 'organizations').of(user).remove(user.organizations);\n        await this.userRepo.remove(user);\n    }\n\n    /**\n     * Revert user from which was banned or recycled\n     *\n     * @param id The specified user id\n     */\n    async revertBannedOrRecycledUser(id: number, status: 'recycled' | 'banned') {\n        const user = await this.findOneById(id);\n        if (status === 'recycled') {\n            user.recycle = false;\n        }\n        if (status === 'banned') {\n            user.banned = false;\n        }\n        await this.userRepo.save(user);\n    }\n\n    /**\n     * Update user's information\n     *\n     * @param id The specified user id\n     * @param updateUserInput The information to be update\n     */\n    async updateUserInfo(id: number, updateUserInput: UpdateUserInput): Promise<void> {\n        const user = await this.userRepo.findOne(id, { relations: ['userInfos'] });\n\n        if (updateUserInput.username) {\n            if (await this.userRepo.findOne({ where: { username: updateUserInput.username } })) {\n                throw new HttpException(t('Username already exists'), 409);\n            }\n            await this.userRepo.update(user.id, { username: updateUserInput.username });\n        }\n        if (updateUserInput.mobile) {\n            if (await this.userRepo.findOne({ where: { mobile: updateUserInput.mobile } })) {\n                throw new HttpException(t('Mobile already exists'), 409);\n            }\n            await this.userRepo.update(user.id, { mobile: updateUserInput.mobile });\n        }\n        if (updateUserInput.email) {\n            if (await this.userRepo.findOne({ where: { email: updateUserInput.email } })) {\n                throw new HttpException(t('Email already exists'), 409);\n            }\n            await this.userRepo.update(user.id, { email: updateUserInput.email.toLocaleLowerCase() });\n        }\n\n        if (updateUserInput.password) {\n            const newPassword = await this.cryptoUtil.encryptPassword(updateUserInput.password);\n            await this.userRepo.update(user.id, { password: newPassword });\n        }\n        if (updateUserInput.roleIds && updateUserInput.roleIds.length) {\n            updateUserInput.roleIds.forEach(async roleId => {\n                await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(user).remove(roleId.before);\n                await this.userRepo.createQueryBuilder('user').relation(User, 'roles').of(user).add(roleId.after);\n            });\n        }\n        if (updateUserInput.organizationIds && updateUserInput.organizationIds.length) {\n            updateUserInput.organizationIds.forEach(async organizationId => {\n                await this.userRepo.createQueryBuilder('user').relation(User, 'organizations').of(user).remove(organizationId.before);\n                await this.userRepo.createQueryBuilder('user').relation(User, 'organizations').of(user).add(organizationId.after);\n            });\n        }\n        if (updateUserInput.infoKVs && updateUserInput.infoKVs.length) {\n            await this.createOrUpdateUserInfos(user, updateUserInput.infoKVs, 'update');\n        }\n    }\n\n    /**\n     * Query the user by role ID\n     *\n     * @param roleId The specified role id\n     */\n    async findByRoleId(roleId: number) {\n        const users = await this.userRepo.createQueryBuilder('user')\n            .leftJoinAndSelect('user.roles', 'roles')\n            .where('roles.id = :roleId', { roleId })\n            .andWhere('user.recycle = false')\n            .getMany();\n        if (!users.length) {\n            throw new HttpException(t('No users belong to this role'), 404);\n        }\n        return this.findUserInfoById(users.map(user => user.id)) as Promise<UserInfoData[]>;\n    }\n\n    /**\n     * Query users that belongs to the organization\n     *\n     * @param id The specified organization id\n     */\n    async findByOrganizationId(organizationId: number): Promise<UserInfoData[]> {\n        const users = await this.userRepo.createQueryBuilder('user')\n            .leftJoinAndSelect('user.organizations', 'organizations')\n            .where('organizations.id = :organizationId', { organizationId })\n            .andWhere('user.recycle = false')\n            .getMany();\n        if (!users.length) {\n            throw new HttpException(t('No users belong to this organization'), 404);\n        }\n        return this.findUserInfoById(users.map(user => user.id)) as Promise<UserInfoData[]>;\n    }\n\n    /**\n     * Querying users and their associated information by username\n     *\n     * @param username username\n     */\n    async findOneWithRolesAndPermissions(loginName: string): Promise<User> {\n        const user = await this.userRepo.createQueryBuilder('user')\n            .leftJoinAndSelect('user.roles', 'roles')\n            .leftJoinAndSelect('roles.permissions', 'permissions')\n            .where('user.username = :loginName', { loginName })\n            .orWhere('user.mobile = :loginName', { loginName })\n            .orWhere('user.email = :loginName', { loginName: loginName.toLocaleLowerCase() })\n            .getOne();\n\n        if (!user) {\n            throw new HttpException(t('User does not exist'), 404);\n        }\n        return user;\n    }\n\n    /**\n     * Querying user information by user ID\n     *\n     * @param id The specified user id\n     */\n    async findUserInfoById(id: number | number[]): Promise<UserInfoData | UserInfoData[]> {\n        const userQb = this.userRepo.createQueryBuilder('user')\n            .leftJoinAndSelect('user.roles', 'roles')\n            .leftJoinAndSelect('user.organizations', 'organizations')\n            .leftJoinAndSelect('user.userInfos', 'userInfos')\n            .leftJoinAndSelect('userInfos.infoItem', 'infoItem');\n\n        const infoItemQb = await this.infoItemRepo.createQueryBuilder('infoItem')\n            .leftJoin('infoItem.infoGroups', 'infoGroups')\n            .leftJoin('infoGroups.role', 'role')\n            .leftJoin('role.users', 'users');\n\n        if (id instanceof Array) {\n            const userInfoData: UserInfoData[] = [];\n            const users = await userQb.whereInIds(id).getMany();\n            const infoItems = await infoItemQb.where('users.id IN (:...id)', { id }).orderBy('infoItem.order', 'ASC').getMany();\n            for (const user of users) {\n                (userInfoData as UserInfoData[]).push(this.refactorUserData(user, infoItems));\n            }\n            return userInfoData;\n        } else {\n            const user = await userQb.where('user.id = :id', { id }).getOne();\n            const infoItem = await infoItemQb.where('users.id = :id', { id }).orderBy('infoItem.order', 'ASC').getMany();\n            return this.refactorUserData(user, infoItem);\n        }\n    }\n\n    /**\n     * Querying all of its information items through a user role\n     *\n     * @param roleIds The specified role id array\n     */\n    async findOneWithInfoItemsByRoleIds(roleIds: number[]) {\n        return this.roleService.findInfoGroupItemsByIds(roleIds);\n    }\n\n    /**\n     * user login by username or email\n     *\n     * @param loginName loginName: username or email\n     * @param password password\n     */\n    async login(loginName: string, password: string) {\n        const user = await this.userRepo.createQueryBuilder('user')\n            .leftJoinAndSelect('user.roles', 'roles')\n            .leftJoinAndSelect('user.organizations', 'organizations')\n            .leftJoinAndSelect('user.userInfos', 'userInfos')\n            .leftJoinAndSelect('userInfos.infoItem', 'infoItem')\n            .where('user.username = :loginName', { loginName })\n            .orWhere('user.mobile = :loginName', { loginName })\n            .orWhere('user.email = :loginName', { loginName: loginName.toLocaleLowerCase() })\n            .getOne();\n\n        await this.checkUserStatus(user);\n        if (!await this.cryptoUtil.checkPassword(password, user.password)) {\n            throw new HttpException(t('invalid password'), 406);\n        }\n\n        const infoItem = await this.infoItemRepo.createQueryBuilder('infoItem')\n            .leftJoin('infoItem.infoGroups', 'infoGroups')\n            .leftJoin('infoGroups.role', 'role')\n            .leftJoin('role.users', 'users')\n            .where('users.username = :loginName', { loginName })\n            .orWhere('users.mobile = :loginName', { loginName })\n            .orWhere('users.email = :loginName', { loginName: loginName.toLocaleLowerCase() })\n            .orderBy('infoItem.order', 'ASC')\n            .getMany();\n\n        const userInfoData = this.refactorUserData(user, infoItem);\n\n        const tokenInfo = await this.authService.createToken({ loginName });\n        return { tokenInfo, userInfoData };\n    }\n\n    /**\n     * user login by mobile (use tencent cloud sms service)\n     *\n     * @param mobile mobile\n     * @param validationCode validationCode\n     */\n    async mobileLogin(mobile: string, validationCode: number) {\n        await this.smsComponentProvider.smsValidator(mobile, validationCode);\n\n        const user = await this.userRepo.findOne({ mobile }, { relations: ['roles', 'organizations', 'userInfos', 'userInfos.infoItem'] });\n        await this.checkUserStatus(user);\n\n        const infoItem = await this.infoItemRepo.createQueryBuilder('infoItem')\n            .leftJoin('infoItem.infoGroups', 'infoGroups')\n            .leftJoin('infoGroups.role', 'role')\n            .leftJoin('role.users', 'users')\n            .where('users.mobile = :mobile', { mobile })\n            .orderBy('infoItem.order', 'ASC')\n            .getMany();\n\n        const userInfoData = this.refactorUserData(user, infoItem);\n\n        const tokenInfo = await this.authService.createToken({ loginName: mobile });\n        return { tokenInfo, userInfoData };\n    }\n\n    /**\n     * Ordinary user registration\n     *\n     * @param username username\n     * @param password password\n     */\n    async register(createUserInput: CreateUserInput): Promise<void> {\n        createUserInput.roleIds = [1];\n        await this.createUser(createUserInput);\n    }\n\n    private checkUserStatus(user: User) {\n        if (!user) throw new HttpException(t('User does not exist'), 404);\n        if (user.banned || user.recycle) throw new HttpException(t('User is banned'), 400);\n    }\n\n    /**\n     * Query users by ID\n     *\n     * @param id The specified user id\n     */\n    private async findOneById(id: number): Promise<User> {\n        const exist = this.userRepo.findOne(id);\n        if (!exist) {\n            throw new HttpException(t('User does not exist'), 404);\n        }\n        return exist;\n    }\n\n    /**\n     * Create or update the value of a user information item\n     *\n     * @param user The user object\n     * @param infoKVs Information item key-value pair, key is the ID of the information item (infoItem.id),\n     * and the value is the value of the information item (userInfo.value)\n     *\n     * @param action Operation type, create or update (create | update)\n     */\n    private async createOrUpdateUserInfos(user: User, infoKVs: { key: number, value: string, relationId?: number }[], action: 'create' | 'update') {\n        if (infoKVs.length) {\n            if (action === 'create') {\n                infoKVs.forEach(async infoKV => {\n                    await this.userInfoRepo.save(this.userInfoRepo.create({ value: infoKV.value, user, infoItem: { id: infoKV.key } }));\n                });\n                return;\n            }\n\n            infoKVs.forEach(async infoKV => {\n                if (infoKV.key) {\n                    this.userInfoRepo.update(infoKV.key, { value: infoKV.value });\n                } else {\n                    await this.userInfoRepo.save(this.userInfoRepo.create({ value: infoKV.value, user, infoItem: { id: infoKV.relationId } }));\n                }\n            });\n        }\n    }\n\n    /**\n     * Refactor the user information data\n     *\n     * @param user The user object\n     */\n    private refactorUserData(user: User, infoItems: InfoItem[]) {\n        const userInfoData: UserInfoData = {\n            userId: user.id,\n            username: user.username,\n            email: user.email,\n            mobile: user.mobile,\n            banned: user.banned,\n            recycle: user.recycle,\n            createTime: user.createTime,\n            updateTime: user.updateTime,\n            userRoles: user.roles,\n            userOrganizations: user.organizations,\n            userInfos: infoItems.length ? infoItems.map(infoItem => {\n                const userInfo = user.userInfos.find(userInfo => userInfo.infoItem.id === infoItem.id);\n                return {\n                    id: user.userInfos.length ? (userInfo ? userInfo.id : undefined) : undefined,\n                    order: infoItem.order,\n                    relationId: infoItem.id,\n                    type: infoItem.type,\n                    name: infoItem.name,\n                    value: user.userInfos.length ? (userInfo ? userInfo.value : undefined) : undefined,\n                    description: infoItem.description,\n                    registerDisplay: infoItem.registerDisplay,\n                    informationDisplay: infoItem.informationDisplay\n                };\n            }) : []\n        };\n        return userInfoData;\n    }\n}"]}